{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"ABsolute SOLVantion Free Energy Calculations <p>Absolute solvation free energy calculations using OpenMM</p> <p> </p> <p>The <code>absolv</code> framework aims to offer a simple API for computing the change in free energy when transferring a solute from one solvent to another, or to vacuum in the case of solvation free energy calculations.</p> <p>It offers two routes to this end: standard equilibrium calculations and non-equilibrium switching type calculations, where the latter will be the main focus of this framework.</p> <p>Warning</p> <p>This code is currently experimental and under active development. If you are using this it, please be aware that it is not guaranteed to provide correct results, the documentation and testing may be incomplete, and the API may change without notice.</p>"},{"location":"#installation","title":"Installation","text":"<p>This package can be installed using <code>conda</code> (or <code>mamba</code>, a faster version of <code>conda</code>):</p> <pre><code>mamba install -c conda-forge absolv\n</code></pre> <p>If you are running with MPI on an HPC cluster, you may need to instruct conda to use your local installation depending on your setup</p> <pre><code>mamba install -c conda-forge absolv \"openmpi=4.1.5=*external*\"\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started, see the usage guide.</p>"},{"location":"development/","title":"Development","text":"<p>To create a development environment, you must have <code>mamba</code> installed.</p> <p>A development conda environment can be created and activated with:</p> <pre><code>make env\nconda activate absolv\n</code></pre> <p>To format the codebase:</p> <pre><code>make format\n</code></pre> <p>To run the unit tests:</p> <pre><code>make test\n</code></pre> <p>To serve the documentation locally:</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"reproducibility/","title":"Reproducibility","text":"<p>While every effort has been made to ensure the 'correctness and reproducibility' of any results computed using this framework, achieving consistent free energies between different frameworks and simulation engines has been notoriously tricky <sup>1</sup>.</p> <p>In an attempt to ensure that this framework remains at least self-consistent between versions, and as consistent as possible with other packages, a suite of regression tests are provided in the main GitHub repository.</p> <p>These include tests to ensure that computing the free energies using both the 'equilibrium' and 'non-equilibrium' methods supported in this framework are in agreement amongst themselves, and with the GROMACS values reported by Loeffler et al <sup>1</sup>.</p>"},{"location":"reproducibility/#regression-results","title":"Regression Results","text":"<p>The results of running the free energy comparisons using the latest version of the framework are shown below:</p> <p> </p> The average hydration free energies of methane, methanol, toluene, and               2-cyclopentanylindole computed using the 'equilibrium' and               'non-equilibrium' methods across three replicas. The error bars show the               standard deviation computed across three replicas.    <ol> <li> <p>Hannes H Loeffler, Stefano Bosisio, Guilherme Duarte Ramos Matos, Donghyuk Suh, Benoit Roux, David L Mobley, and Julien Michel. Reproducibility of free energy calculations across different molecular simulation software packages. Journal of chemical theory and computation, 14(11):5567\u20135582, 2018.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"reference/","title":"Index","text":""},{"location":"reference/#absolv","title":"absolv","text":"<p>Absolute solvation free energy calculations using OpenMM</p> <p>Modules:</p> <ul> <li> <code>config</code>           \u2013            <p>Configure free energy calculations.</p> </li> <li> <code>fep</code>           \u2013            <p>Prepare OpenMM systems for FEP calculations.</p> </li> <li> <code>neq</code>           \u2013            <p>Run non-equilibrium forward and reverse sampling.</p> </li> <li> <code>runner</code>           \u2013            <p>Run calculations defined by a config.</p> </li> <li> <code>setup</code>           \u2013            <p>Setup systems ready for calculations.</p> </li> <li> <code>tests</code>           \u2013            </li> <li> <code>utils</code>           \u2013            <p>Common utils</p> </li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li> absolv<ul> <li> config</li> <li> fep</li> <li> neq</li> <li> runner</li> <li> setup</li> <li> utils<ul> <li> openmm</li> <li> topology</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/config/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> config","text":""},{"location":"reference/config/#absolv.config","title":"config","text":"<p>Configure free energy calculations.</p> <p>Classes:</p> <ul> <li> <code>System</code>           \u2013            <p>Define the two solvents that solutes will be transferred between (a -&gt; b),</p> </li> <li> <code>MinimizationProtocol</code>           \u2013            <p>Configure how a system should be energy minimized.</p> </li> <li> <code>SimulationProtocol</code>           \u2013            <p>Configure how a system should be evolved by molecular simulation.</p> </li> <li> <code>HREMDProtocol</code>           \u2013            <p>Configure how a system should be evolved by Hamiltonian replica exchange.</p> </li> <li> <code>EquilibriumProtocol</code>           \u2013            <p>Configure how an equilibrium (e.g. TI, MBAR) alchemical free energy</p> </li> <li> <code>SwitchingProtocol</code>           \u2013            <p>Configure non-reversibly driving a system between to alchemical states.</p> </li> <li> <code>NonEquilibriumProtocol</code>           \u2013            <p>Configure a non-equilibrium alchemical free energy calculation [1, 2].</p> </li> <li> <code>Config</code>           \u2013            <p>Configure a transfer free energy calculation.</p> </li> <li> <code>Result</code>           \u2013            <p>The result of a free energy calculation.</p> </li> </ul>"},{"location":"reference/config/#absolv.config.System","title":"System  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Define the two solvents that solutes will be transferred between (a -&gt; b), as well as the solutes themselves.</p> <p>Fields:</p> <ul> <li> <code>solutes</code>                 (<code>dict[str, PositiveInt]</code>)             </li> <li> <code>solvent_a</code>                 (<code>dict[str, PositiveInt] | None</code>)             </li> <li> <code>solvent_b</code>                 (<code>dict[str, PositiveInt] | None</code>)             </li> <li> <code>n_solute_molecules</code>                 (<code>int</code>)             </li> <li> <code>n_solvent_molecules_a</code>                 (<code>int</code>)             </li> <li> <code>n_solvent_molecules_b</code>                 (<code>int</code>)             </li> <li> <code>components_a</code>                 (<code>list[tuple[str, int]]</code>)             </li> <li> <code>components_b</code>                 (<code>list[tuple[str, int]]</code>)             </li> </ul> <p>Validators:</p> <ul> <li> <code>_validate_solvent_a</code> \u2192                 <code>solvent_a</code> </li> <li> <code>_validate_solvent_b</code> \u2192                 <code>solvent_b</code> </li> </ul>"},{"location":"reference/config/#absolv.config.System.solutes","title":"solutes  <code>pydantic-field</code>","text":"<pre><code>solutes: dict[str, PositiveInt]\n</code></pre> <p>A dictionary containing the SMILES patterns of each solute in the system as well as how many instances of each there should be.</p>"},{"location":"reference/config/#absolv.config.System.solvent_a","title":"solvent_a  <code>pydantic-field</code>","text":"<pre><code>solvent_a: dict[str, PositiveInt] | None\n</code></pre> <p>A dictionary containing the SMILES patterns of each component in the first solvent as well as how many instances of each there should be.A value of <code>None</code> should be used to indicate vacuum.</p>"},{"location":"reference/config/#absolv.config.System.solvent_b","title":"solvent_b  <code>pydantic-field</code>","text":"<pre><code>solvent_b: dict[str, PositiveInt] | None\n</code></pre> <p>A dictionary containing the SMILES patterns of each component in the second solvent as well as how many instances of each there should be. A value of <code>None</code> should be used to indicate vacuum.</p>"},{"location":"reference/config/#absolv.config.System.n_solute_molecules","title":"n_solute_molecules  <code>pydantic-field</code>","text":"<pre><code>n_solute_molecules: int\n</code></pre> <p>Returns the total number of solute molecules that will be present.</p>"},{"location":"reference/config/#absolv.config.System.n_solvent_molecules_a","title":"n_solvent_molecules_a  <code>pydantic-field</code>","text":"<pre><code>n_solvent_molecules_a: int\n</code></pre> <p>Returns the total number of solvent molecules that will be present in the first solution.</p>"},{"location":"reference/config/#absolv.config.System.n_solvent_molecules_b","title":"n_solvent_molecules_b  <code>pydantic-field</code>","text":"<pre><code>n_solvent_molecules_b: int\n</code></pre> <p>Returns the total number of solvent molecules that will be present in the second solution.</p>"},{"location":"reference/config/#absolv.config.System.components_a","title":"components_a  <code>pydantic-field</code>","text":"<pre><code>components_a: list[tuple[str, int]]\n</code></pre> <p>Returns the identities and counts of the molecules present in the first system.</p> <p>Returns:</p> <ul> <li> <code>list[tuple[str, int]]</code>           \u2013            <p>The SMILES representation and count of each component.</p> </li> </ul>"},{"location":"reference/config/#absolv.config.System.components_b","title":"components_b  <code>pydantic-field</code>","text":"<pre><code>components_b: list[tuple[str, int]]\n</code></pre> <p>Returns the identities and counts of the molecules present in the second system.</p> <p>Returns:</p> <ul> <li> <code>list[tuple[str, int]]</code>           \u2013            <p>The SMILES representation and count of each component.</p> </li> </ul>"},{"location":"reference/config/#absolv.config.MinimizationProtocol","title":"MinimizationProtocol  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configure how a system should be energy minimized.</p> <p>Fields:</p> <ul> <li> <code>tolerance</code>                 (<code>OpenMMQuantity[kilojoule_per_mole / nanometers]</code>)             </li> <li> <code>max_iterations</code>                 (<code>NonNegativeInt</code>)             </li> </ul>"},{"location":"reference/config/#absolv.config.MinimizationProtocol.tolerance","title":"tolerance  <code>pydantic-field</code>","text":"<pre><code>tolerance: OpenMMQuantity[\n    kilojoule_per_mole / nanometers\n] = (10.0 * kilojoule_per_mole / nanometers)\n</code></pre> <p>How precisely the energy minimum must be located [kj / mol / nm]</p>"},{"location":"reference/config/#absolv.config.MinimizationProtocol.max_iterations","title":"max_iterations  <code>pydantic-field</code>","text":"<pre><code>max_iterations: NonNegativeInt = 0\n</code></pre> <p>The maximum number of iterations to perform. If this is 0, minimization is continued until the results converge.</p>"},{"location":"reference/config/#absolv.config.SimulationProtocol","title":"SimulationProtocol  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configure how a system should be evolved by molecular simulation.</p> <p>Fields:</p> <ul> <li> <code>integrator</code>                 (<code>LangevinIntegrator</code>)             </li> <li> <code>n_steps</code>                 (<code>PositiveInt</code>)             </li> </ul>"},{"location":"reference/config/#absolv.config.SimulationProtocol.integrator","title":"integrator  <code>pydantic-field</code>","text":"<pre><code>integrator: LangevinIntegrator = LangevinIntegrator(\n    timestep=2.0 * femtosecond, friction=1.0 / picosecond\n)\n</code></pre> <p>The integrator to use for the simulation.</p>"},{"location":"reference/config/#absolv.config.SimulationProtocol.n_steps","title":"n_steps  <code>pydantic-field</code>","text":"<pre><code>n_steps: PositiveInt\n</code></pre> <p>The number of steps to evolve the system by.</p>"},{"location":"reference/config/#absolv.config.HREMDProtocol","title":"HREMDProtocol  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configure how a system should be evolved by Hamiltonian replica exchange.</p> <p>Fields:</p> <ul> <li> <code>integrator</code>                 (<code>LangevinIntegrator</code>)             </li> <li> <code>n_warmup_steps</code>                 (<code>int</code>)             </li> <li> <code>n_steps_per_cycle</code>                 (<code>int</code>)             </li> <li> <code>n_cycles</code>                 (<code>int</code>)             </li> <li> <code>trajectory_interval</code>                 (<code>int | None</code>)             </li> <li> <code>trajectory_enforce_pbc</code>                 (<code>bool</code>)             </li> </ul>"},{"location":"reference/config/#absolv.config.HREMDProtocol.integrator","title":"integrator  <code>pydantic-field</code>","text":"<pre><code>integrator: LangevinIntegrator = LangevinIntegrator(\n    timestep=2.0 * femtosecond, friction=1.0 / picosecond\n)\n</code></pre> <p>The integrator to use for the simulation.</p>"},{"location":"reference/config/#absolv.config.HREMDProtocol.n_warmup_steps","title":"n_warmup_steps  <code>pydantic-field</code>","text":"<pre><code>n_warmup_steps: int = 50000\n</code></pre> <p>The number of steps to run each replica for before starting hremd trials. All energies gathered during this period will be discarded.</p>"},{"location":"reference/config/#absolv.config.HREMDProtocol.n_steps_per_cycle","title":"n_steps_per_cycle  <code>pydantic-field</code>","text":"<pre><code>n_steps_per_cycle: int = 1000\n</code></pre> <p>The number of steps to propagate the system by before attempting an exchange.</p>"},{"location":"reference/config/#absolv.config.HREMDProtocol.n_cycles","title":"n_cycles  <code>pydantic-field</code>","text":"<pre><code>n_cycles: int = 2500\n</code></pre> <p>The number of cycles of 'propagate the system' -&gt; 'exchange replicas' to run.</p>"},{"location":"reference/config/#absolv.config.HREMDProtocol.trajectory_interval","title":"trajectory_interval  <code>pydantic-field</code>","text":"<pre><code>trajectory_interval: int | None = None\n</code></pre> <p>The number of cycles to run before saving the current replica states to DCD trajectory files. If <code>None</code>, no trajectories will be saved.</p>"},{"location":"reference/config/#absolv.config.HREMDProtocol.trajectory_enforce_pbc","title":"trajectory_enforce_pbc  <code>pydantic-field</code>","text":"<pre><code>trajectory_enforce_pbc: bool = False\n</code></pre> <p>Whether to apply periodic boundary conditions when retrieving coordinates for writing to trajectory files.</p>"},{"location":"reference/config/#absolv.config.EquilibriumProtocol","title":"EquilibriumProtocol  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configure how an equilibrium (e.g. TI, MBAR) alchemical free energy calculation.</p> <p>Fields:</p> <ul> <li> <code>type</code>                 (<code>Literal['equilibrium']</code>)             </li> <li> <code>minimization_protocol</code>                 (<code>MinimizationProtocol</code>)             </li> <li> <code>equilibration_protocol</code>                 (<code>SimulationProtocol</code>)             </li> <li> <code>production_protocol</code>                 (<code>HREMDProtocol</code>)             </li> <li> <code>lambda_sterics</code>                 (<code>list[confloat(ge=0.0, le=1.0)]</code>)             </li> <li> <code>lambda_electrostatics</code>                 (<code>list[confloat(ge=0.0, le=1.0)]</code>)             </li> <li> <code>n_states</code>                 (<code>int</code>)             </li> </ul>"},{"location":"reference/config/#absolv.config.EquilibriumProtocol.minimization_protocol","title":"minimization_protocol  <code>pydantic-field</code>","text":"<pre><code>minimization_protocol: MinimizationProtocol = (\n    MinimizationProtocol()\n)\n</code></pre> <p>Whether to minimize the energy of the system prior to any simulations.</p>"},{"location":"reference/config/#absolv.config.EquilibriumProtocol.equilibration_protocol","title":"equilibration_protocol  <code>pydantic-field</code>","text":"<pre><code>equilibration_protocol: SimulationProtocol = (\n    SimulationProtocol(n_steps=100000)\n)\n</code></pre> <p>The (optional) protocol that describes the equilibration simulation to run prior to the production one.</p>"},{"location":"reference/config/#absolv.config.EquilibriumProtocol.production_protocol","title":"production_protocol  <code>pydantic-field</code>","text":"<pre><code>production_protocol: HREMDProtocol = HREMDProtocol(\n    n_steps_per_cycle=6250, n_cycles=160\n)\n</code></pre> <p>The protocol that describes the production to run.</p>"},{"location":"reference/config/#absolv.config.EquilibriumProtocol.lambda_sterics","title":"lambda_sterics  <code>pydantic-field</code>","text":"<pre><code>lambda_sterics: list[confloat(ge=0.0, le=1.0)]\n</code></pre> <p>The alchemical pathway to transform the vdW interactions along. A value of 1.0 represents a fully interacting system while a value of 0.0 represents a system with the solute-solute and solute-solvent vdW interactions disabled.</p>"},{"location":"reference/config/#absolv.config.EquilibriumProtocol.lambda_electrostatics","title":"lambda_electrostatics  <code>pydantic-field</code>","text":"<pre><code>lambda_electrostatics: list[confloat(ge=0.0, le=1.0)]\n</code></pre> <p>The alchemical pathway to transform the electrostatic interactions along. A value of 1.0 represents a fully interacting system while a value of 0.0 represents a system with the solute-solute and solute-solvent electrostatic interactions disabled.</p>"},{"location":"reference/config/#absolv.config.EquilibriumProtocol.n_states","title":"n_states  <code>pydantic-field</code>","text":"<pre><code>n_states: int\n</code></pre> <p>Returns the number of lambda states that will be sampled at.</p>"},{"location":"reference/config/#absolv.config.SwitchingProtocol","title":"SwitchingProtocol  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configure non-reversibly driving a system between to alchemical states.</p> <p>Fields:</p> <ul> <li> <code>n_electrostatic_steps</code>                 (<code>NonNegativeInt</code>)             </li> <li> <code>n_steps_per_electrostatic_step</code>                 (<code>NonNegativeInt</code>)             </li> <li> <code>n_steric_steps</code>                 (<code>NonNegativeInt</code>)             </li> <li> <code>n_steps_per_steric_step</code>                 (<code>NonNegativeInt</code>)             </li> </ul>"},{"location":"reference/config/#absolv.config.SwitchingProtocol.n_electrostatic_steps","title":"n_electrostatic_steps  <code>pydantic-field</code>","text":"<pre><code>n_electrostatic_steps: NonNegativeInt\n</code></pre> <p>The number of steps to annihilate the electrostatics interactions over. The total time needed to annihilate the electrostatics interactions will be <code>n_electrostatic_steps * n_steps_per_electrostatic_step * timestep</code></p>"},{"location":"reference/config/#absolv.config.SwitchingProtocol.n_steps_per_electrostatic_step","title":"n_steps_per_electrostatic_step  <code>pydantic-field</code>","text":"<pre><code>n_steps_per_electrostatic_step: NonNegativeInt\n</code></pre> <p>The number of timesteps to evolve the system by each time the electrostatics interactions are modified. A value of 1 will give a 'smooth' transition between the each discrete lambda value whereas a value greater than 1 will yield a stepwise transition as shown in Figure 3 of doi:10.1063/1.4712028.</p>"},{"location":"reference/config/#absolv.config.SwitchingProtocol.n_steric_steps","title":"n_steric_steps  <code>pydantic-field</code>","text":"<pre><code>n_steric_steps: NonNegativeInt\n</code></pre> <p>The number of steps to decouple the sterics interactions over once the electrostatics interactions have been annihilated. The total time needed to annihilate the sterics interactions will be <code>n_steric_steps * n_steps_per_steric_step * timestep</code></p>"},{"location":"reference/config/#absolv.config.SwitchingProtocol.n_steps_per_steric_step","title":"n_steps_per_steric_step  <code>pydantic-field</code>","text":"<pre><code>n_steps_per_steric_step: NonNegativeInt\n</code></pre> <p>The number of timesteps to evolve the system by each time the sterics interactions are modified. A value of 1 will give a 'smooth' transition between the each discrete lambda value whereas a value greater than 1 will yield a stepwise transition as shown in Figure 3 of doi:10.1063/1.4712028.</p>"},{"location":"reference/config/#absolv.config.NonEquilibriumProtocol","title":"NonEquilibriumProtocol  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configure a non-equilibrium alchemical free energy calculation [1, 2].</p> <p>It is expected that first the electrostatics interactions will be annihilated followed by a decoupling of the sterics interactions.</p> References <p>[1] Ballard, Andrew J., and Christopher Jarzynski. \"Replica exchange with     nonequilibrium switches: Enhancing equilibrium sampling by increasing     replica overlap.\" The Journal of chemical physics 136.19 (2012): 194101.</p> <p>[2] Gapsys, Vytautas, et al. \"Large scale relative protein ligand binding     affinities using non-equilibrium alchemy.\" Chemical Science 11.4 (2020):     1140-1152.</p> <p>Fields:</p> <ul> <li> <code>type</code>                 (<code>Literal['non-equilibrium']</code>)             </li> <li> <code>minimization_protocol</code>                 (<code>MinimizationProtocol | None</code>)             </li> <li> <code>equilibration_protocol</code>                 (<code>SimulationProtocol | None</code>)             </li> <li> <code>production_protocol</code>                 (<code>SimulationProtocol</code>)             </li> <li> <code>production_report_interval</code>                 (<code>PositiveInt</code>)             </li> <li> <code>switching_protocol</code>                 (<code>SwitchingProtocol</code>)             </li> </ul>"},{"location":"reference/config/#absolv.config.NonEquilibriumProtocol.minimization_protocol","title":"minimization_protocol  <code>pydantic-field</code>","text":"<pre><code>minimization_protocol: MinimizationProtocol | None = (\n    MinimizationProtocol()\n)\n</code></pre> <p>The (optional) protocol to follow when minimizing the system in both the end states prior to running the equilibrium simulations.</p>"},{"location":"reference/config/#absolv.config.NonEquilibriumProtocol.equilibration_protocol","title":"equilibration_protocol  <code>pydantic-field</code>","text":"<pre><code>equilibration_protocol: SimulationProtocol | None = (\n    SimulationProtocol(n_steps=100000)\n)\n</code></pre> <p>The (optional) protocol to follow when equilibrating the system in both the end states prior to running the production equilibrium simulations.</p>"},{"location":"reference/config/#absolv.config.NonEquilibriumProtocol.production_protocol","title":"production_protocol  <code>pydantic-field</code>","text":"<pre><code>production_protocol: SimulationProtocol = (\n    SimulationProtocol(n_steps=6250 * 160)\n)\n</code></pre> <p>The protocol to follow when running the production equilibrium simulation in both the end states. The snapshots generated at the end of each iteration will be used for each non-equilibrium switch.</p>"},{"location":"reference/config/#absolv.config.NonEquilibriumProtocol.production_report_interval","title":"production_report_interval  <code>pydantic-field</code>","text":"<pre><code>production_report_interval: PositiveInt = 6250\n</code></pre> <p>The interval at which to write out the simulation state during the production simulation.</p>"},{"location":"reference/config/#absolv.config.NonEquilibriumProtocol.switching_protocol","title":"switching_protocol  <code>pydantic-field</code>","text":"<pre><code>switching_protocol: SwitchingProtocol\n</code></pre> <p>The protocol that describes how each snapshot generated during the production simulation should be driven from state 0 -&gt; 1 and likewise 1 -&gt; 0 in order to compute the non-equilibrium work distributions.</p>"},{"location":"reference/config/#absolv.config.Config","title":"Config  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configure a transfer free energy calculation.</p> <p>Fields:</p> <ul> <li> <code>temperature</code>                 (<code>OpenMMQuantity[kelvin]</code>)             </li> <li> <code>pressure</code>                 (<code>OpenMMQuantity[atmosphere] | None</code>)             </li> <li> <code>alchemical_protocol_a</code>                 (<code>AlchemicalProtocol</code>)             </li> <li> <code>alchemical_protocol_b</code>                 (<code>AlchemicalProtocol</code>)             </li> </ul>"},{"location":"reference/config/#absolv.config.Config.temperature","title":"temperature  <code>pydantic-field</code>","text":"<pre><code>temperature: OpenMMQuantity[kelvin]\n</code></pre> <p>The temperature to calculate at [K].</p>"},{"location":"reference/config/#absolv.config.Config.pressure","title":"pressure  <code>pydantic-field</code>","text":"<pre><code>pressure: OpenMMQuantity[atmosphere] | None\n</code></pre> <p>The pressure to calculate at [atm].</p>"},{"location":"reference/config/#absolv.config.Config.alchemical_protocol_a","title":"alchemical_protocol_a  <code>pydantic-field</code>","text":"<pre><code>alchemical_protocol_a: AlchemicalProtocol\n</code></pre> <p>The protocol that describes the alchemical pathway to transform the solute along in the first solvent.</p>"},{"location":"reference/config/#absolv.config.Config.alchemical_protocol_b","title":"alchemical_protocol_b  <code>pydantic-field</code>","text":"<pre><code>alchemical_protocol_b: AlchemicalProtocol\n</code></pre> <p>The protocol that describes the alchemical pathway to transform the solute along in the second solvent.</p>"},{"location":"reference/config/#absolv.config.Result","title":"Result  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The result of a free energy calculation.</p> <p>Fields:</p> <ul> <li> <code>dg_solvent_a</code>                 (<code>OpenMMQuantity[KCAL_MOL]</code>)             </li> <li> <code>dg_std_solvent_a</code>                 (<code>OpenMMQuantity[KCAL_MOL]</code>)             </li> <li> <code>dg_solvent_b</code>                 (<code>OpenMMQuantity[KCAL_MOL]</code>)             </li> <li> <code>dg_std_solvent_b</code>                 (<code>OpenMMQuantity[KCAL_MOL]</code>)             </li> </ul>"},{"location":"reference/config/#absolv.config.Result.dg_solvent_a","title":"dg_solvent_a  <code>pydantic-field</code>","text":"<pre><code>dg_solvent_a: OpenMMQuantity[KCAL_MOL]\n</code></pre> <p>The change in free energy of alchemically transforming the solute from an interacting to a non-interacting state in the first solvent.</p>"},{"location":"reference/config/#absolv.config.Result.dg_std_solvent_a","title":"dg_std_solvent_a  <code>pydantic-field</code>","text":"<pre><code>dg_std_solvent_a: OpenMMQuantity[KCAL_MOL]\n</code></pre> <p>The standard error in <code>dg_solvent_a</code>.</p>"},{"location":"reference/config/#absolv.config.Result.dg_solvent_b","title":"dg_solvent_b  <code>pydantic-field</code>","text":"<pre><code>dg_solvent_b: OpenMMQuantity[KCAL_MOL]\n</code></pre> <p>The change in free energy of alchemically transforming the solute from an interacting to a non-interacting state in the second solvent.</p>"},{"location":"reference/config/#absolv.config.Result.dg_std_solvent_b","title":"dg_std_solvent_b  <code>pydantic-field</code>","text":"<pre><code>dg_std_solvent_b: OpenMMQuantity[KCAL_MOL]\n</code></pre> <p>The standard error in <code>dg_solvent_b</code>.</p>"},{"location":"reference/fep/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> fep","text":""},{"location":"reference/fep/#absolv.fep","title":"fep","text":"<p>Prepare OpenMM systems for FEP calculations.</p> <p>Functions:</p> <ul> <li> <code>apply_fep</code>             \u2013              <p>Generate a system whereby a number of the molecules can be alchemically</p> </li> <li> <code>set_fep_lambdas</code>             \u2013              <p>Set the values of the alchemical lambdas on an OpenMM context.</p> </li> </ul>"},{"location":"reference/fep/#absolv.fep.apply_fep","title":"apply_fep","text":"<pre><code>apply_fep(\n    system: System,\n    alchemical_indices: list[set[int]],\n    persistent_indices: list[set[int]],\n    custom_alchemical_potential: str | None = None,\n) -&gt; System\n</code></pre> <p>Generate a system whereby a number of the molecules can be alchemically transformed from a base chemical system.</p> Notes <ul> <li> <p>Currently only OpenMM systems that have:</p> </li> <li> <p>vdW + electrostatics in a single built-in non-bonded force</p> </li> <li>electrostatics in a built-in non-bonded force, vdW in a custom     non-bonded force and vdW 1-4 interactions in a custom bond force</li> <li>all of the above sans any electrostatics</li> </ul> <p>are supported. * By default a soft-core version of the LJ potential with a-b-c of 1-1-6   and alpha=0.5 that can be scaled by a global <code>lambda_sterics</code> parameter   will be used for alchemical-chemical vdW interactions embedded in an   OpenMM <code>NonbondedForce</code> while the energy expression set on a   <code>CustomNonbondedForce</code> will be be modified to have the form   <code>\"lambda_sterics*({original_expression})\"</code>.</p> <p>Parameters:</p> <ul> <li> <code>system</code>               (<code>System</code>)           \u2013            <p>The chemical system to generate the alchemical system from</p> </li> <li> <code>alchemical_indices</code>               (<code>list[set[int]]</code>)           \u2013            <p>The atom indices corresponding to each molecule that should be alchemically transformable. The atom indices must correspond to  all atoms in each molecule as alchemically transforming part of a molecule is not supported.</p> </li> <li> <code>persistent_indices</code>               (<code>list[set[int]]</code>)           \u2013            <p>The atom indices corresponding to each molecule that should not be alchemically transformable.</p> </li> <li> <code>custom_alchemical_potential</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A custom expression to use for the potential energy function that describes the chemical-alchemical intermolecular interactions. See the Notes for information about the default value.</p> <p>The expression must include <code>\"lambda_sterics\"</code>.</p> </li> </ul> Source code in <code>absolv/fep.py</code> <pre><code>def apply_fep(\n    system: openmm.System,\n    alchemical_indices: list[set[int]],\n    persistent_indices: list[set[int]],\n    custom_alchemical_potential: str | None = None,\n) -&gt; openmm.System:\n    \"\"\"Generate a system whereby a number of the molecules can be alchemically\n    transformed from a base chemical system.\n\n    Notes:\n        * Currently only OpenMM systems that have:\n\n          - vdW + electrostatics in a single built-in non-bonded force\n          - electrostatics in a built-in non-bonded force, vdW in a custom\n            **non-bonded** force and vdW 1-4 interactions in a custom **bond** force\n          - all of the above sans any electrostatics\n\n          are supported.\n        * By default a soft-core version of the LJ potential with a-b-c of 1-1-6\n          and alpha=0.5 that can be scaled by a global `lambda_sterics` parameter\n          will be used for alchemical-chemical vdW interactions embedded in an\n          OpenMM ``NonbondedForce`` while the energy expression set on a\n          ``CustomNonbondedForce`` will be be modified to have the form\n          ``\"lambda_sterics*({original_expression})\"``.\n\n    Args:\n        system: The chemical system to generate the alchemical system from\n        alchemical_indices: The atom indices corresponding to each molecule that\n            should be alchemically transformable. The atom indices **must**\n            correspond to  **all** atoms in each molecule as alchemically\n            transforming part of a molecule is not supported.\n        persistent_indices: The atom indices corresponding to each molecule that\n            should **not** be alchemically transformable.\n        custom_alchemical_potential: A custom expression to use for the potential\n            energy function that describes the chemical-alchemical intermolecular\n            interactions. See the Notes for information about the default value.\n\n            The expression **must** include ``\"lambda_sterics\"``.\n    \"\"\"\n\n    system = copy.deepcopy(system)\n\n    # Make sure we track v-sites attached to any solutes that may be alchemically\n    # turned off. We do this as a post-process step as the OpenFF toolkit does not\n    # currently expose a clean way to access this information.\n    atom_indices = alchemical_indices + persistent_indices\n    atom_indices = _find_v_sites(system, atom_indices)\n\n    alchemical_indices = atom_indices[: len(alchemical_indices)]\n    persistent_indices = atom_indices[len(alchemical_indices) :]\n\n    (\n        nonbonded_force,\n        custom_nonbonded_force,\n        custom_bond_force,\n    ) = _find_nonbonded_forces(system)\n\n    if nonbonded_force is not None:\n        _add_electrostatics_lambda(nonbonded_force, alchemical_indices)\n\n    if custom_nonbonded_force is not None:\n        for alchemical_force in _add_custom_vdw_lambda(\n            custom_nonbonded_force,\n            alchemical_indices,\n            persistent_indices,\n            custom_alchemical_potential,\n        ):\n            system.addForce(alchemical_force)\n\n    elif nonbonded_force is not None:\n        for alchemical_force in _add_lj_vdw_lambda(\n            nonbonded_force,\n            alchemical_indices,\n            persistent_indices,\n            custom_alchemical_potential,\n        ):\n            system.addForce(alchemical_force)\n\n    else:\n        raise NotImplementedError\n\n    return system\n</code></pre>"},{"location":"reference/fep/#absolv.fep.set_fep_lambdas","title":"set_fep_lambdas","text":"<pre><code>set_fep_lambdas(\n    context: Context,\n    lambda_sterics: float | None = None,\n    lambda_electrostatics: float | None = None,\n)\n</code></pre> <p>Set the values of the alchemical lambdas on an OpenMM context.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>Context</code>)           \u2013            <p>The context to update.</p> </li> <li> <code>lambda_sterics</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) value of the steric lambda.</p> </li> <li> <code>lambda_electrostatics</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) value of the electrostatics lambda.</p> </li> </ul> Source code in <code>absolv/fep.py</code> <pre><code>def set_fep_lambdas(\n    context: openmm.Context,\n    lambda_sterics: float | None = None,\n    lambda_electrostatics: float | None = None,\n):\n    \"\"\"Set the values of the alchemical lambdas on an OpenMM context.\n\n    Args:\n        context: The context to update.\n        lambda_sterics: The (optional) value of the steric lambda.\n        lambda_electrostatics: The (optional) value of the electrostatics lambda.\n    \"\"\"\n\n    if lambda_sterics is not None:\n        assert (\n            0.0 &lt;= lambda_sterics &lt;= 1.0\n        ), f\"`{LAMBDA_STERICS}` must be between 0 and 1\"\n        context.setParameter(LAMBDA_STERICS, lambda_sterics)\n\n    if lambda_electrostatics is not None:\n        assert (\n            0.0 &lt;= lambda_electrostatics &lt;= 1.0\n        ), f\"`{LAMBDA_ELECTROSTATICS}` must be between 0 and 1\"\n\n        context.setParameter(LAMBDA_ELECTROSTATICS, lambda_electrostatics)\n</code></pre>"},{"location":"reference/neq/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> neq","text":""},{"location":"reference/neq/#absolv.neq","title":"neq","text":"<p>Run non-equilibrium forward and reverse sampling.</p> <p>Modules:</p> <ul> <li> <code>absolv</code>           \u2013            <p>Absolute solvation free energy calculations using OpenMM</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>run_neq</code>             \u2013              <p>Run a non-equilibrium simulation with OpenMM, whereby a system is non-reversibly</p> </li> </ul>"},{"location":"reference/neq/#absolv.neq.run_neq","title":"run_neq","text":"<pre><code>run_neq(\n    simulation: Simulation,\n    coords_0: State,\n    coords_1: State,\n    protocol: SwitchingProtocol,\n) -&gt; tuple[float, float]\n</code></pre> <p>Run a non-equilibrium simulation with OpenMM, whereby a system is non-reversibly pulled along an alchemical pathway as described by Ballard and Jarzynski [1] (Figure 3) and Gapsys et al [2].</p> <p>Both the forward and reverse directions will be simulated.</p> References <p>[1] Ballard, Andrew J., and Christopher Jarzynski. \"Replica exchange with nonequilibrium switches: Enhancing equilibrium sampling by increasing replica overlap.\" The Journal of chemical physics 136.19 (2012): 194101.</p> <p>[2] Gapsys, Vytautas, et al. \"Large scale relative protein ligand binding affinities using non-equilibrium alchemy.\" Chemical Science 11.4 (2020): 1140-1152.</p> <p>Returns:</p> <ul> <li> <code>tuple[float, float]</code>           \u2013            <p>The forward and reverse work values.</p> </li> </ul> Source code in <code>absolv/neq.py</code> <pre><code>def run_neq(\n    simulation: openmm.app.Simulation,\n    coords_0: openmm.State,\n    coords_1: openmm.State,\n    protocol: absolv.config.SwitchingProtocol,\n) -&gt; tuple[float, float]:\n    \"\"\"Run a non-equilibrium simulation with OpenMM, whereby a system is non-reversibly\n    pulled along an alchemical pathway as described by Ballard and Jarzynski [1]\n    (Figure 3) and Gapsys et al [2].\n\n    Both the forward and reverse directions will be simulated.\n\n    References:\n        [1] Ballard, Andrew J., and Christopher Jarzynski. \"Replica exchange with\n        nonequilibrium switches: Enhancing equilibrium sampling by increasing replica\n        overlap.\" The Journal of chemical physics 136.19 (2012): 194101.\n\n        [2] Gapsys, Vytautas, et al. \"Large scale relative protein ligand binding\n        affinities using non-equilibrium alchemy.\" Chemical Science 11.4 (2020):\n        1140-1152.\n\n    Returns:\n        The forward and reverse work values.\n    \"\"\"\n\n    forward_potentials = _simulate(\n        simulation, coords_0, protocol, reverse_direction=False\n    )\n    reverse_potentials = _simulate(\n        simulation, coords_1, protocol, reverse_direction=True\n    )\n\n    forward_work = (forward_potentials[:, 1] - forward_potentials[:, 0]).sum()\n    reverse_work = (reverse_potentials[:, 1] - reverse_potentials[:, 0]).sum()\n\n    return forward_work, reverse_work\n</code></pre>"},{"location":"reference/runner/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> runner","text":""},{"location":"reference/runner/#absolv.runner","title":"runner","text":"<p>Run calculations defined by a config.</p> <p>Modules:</p> <ul> <li> <code>absolv</code>           \u2013            <p>Absolute solvation free energy calculations using OpenMM</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>PreparedSystem</code>           \u2013            <p>A container for the prepared inputs for a particular solvent phase.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>setup</code>             \u2013              <p>Prepare each system to be simulated, namely the ligand in each solvent.</p> </li> <li> <code>run_eq</code>             \u2013              <p>Perform a simulation at each lambda window and for each solvent.</p> </li> <li> <code>run_neq</code>             \u2013              <p>Performs the simulations required to estimate the free energy using a</p> </li> </ul>"},{"location":"reference/runner/#absolv.runner.PreparedSystem","title":"PreparedSystem","text":"<p>               Bases: <code>NamedTuple</code></p> <p>A container for the prepared inputs for a particular solvent phase.</p> <p>Attributes:</p> <ul> <li> <code>system</code>               (<code>System</code>)           \u2013            <p>The alchemically modified OpenMM system.</p> </li> <li> <code>topology</code>               (<code>Topology</code>)           \u2013            <p>The OpenFF topology with any box vectors set.</p> </li> <li> <code>coords</code>               (<code>Quantity</code>)           \u2013            <p>The coordinates of the system.</p> </li> </ul>"},{"location":"reference/runner/#absolv.runner.PreparedSystem.system","title":"system  <code>instance-attribute</code>","text":"<pre><code>system: System\n</code></pre> <p>The alchemically modified OpenMM system.</p>"},{"location":"reference/runner/#absolv.runner.PreparedSystem.topology","title":"topology  <code>instance-attribute</code>","text":"<pre><code>topology: Topology\n</code></pre> <p>The OpenFF topology with any box vectors set.</p>"},{"location":"reference/runner/#absolv.runner.PreparedSystem.coords","title":"coords  <code>instance-attribute</code>","text":"<pre><code>coords: Quantity\n</code></pre> <p>The coordinates of the system.</p>"},{"location":"reference/runner/#absolv.runner.setup","title":"setup","text":"<pre><code>setup(\n    system: System,\n    config: Config,\n    force_field: ForceField | SystemGenerator,\n    custom_alchemical_potential: str | None = None,\n) -&gt; tuple[PreparedSystem, PreparedSystem]\n</code></pre> <p>Prepare each system to be simulated, namely the ligand in each solvent.</p> <p>Parameters:</p> <ul> <li> <code>system</code>               (<code>System</code>)           \u2013            <p>The system to prepare.</p> </li> <li> <code>config</code>               (<code>Config</code>)           \u2013            <p>The config defining the calculation to perform.</p> </li> <li> <code>force_field</code>               (<code>ForceField | SystemGenerator</code>)           \u2013            <p>The force field, or a callable that transforms an OpenFF topology into an OpenMM system, without any alchemical modifications to run the calculations using.</p> <p>If a callable is specified, it should take arguments of an OpenFF topology, a unit wrapped numpy array of atom coords, and a string literal with a value of either <code>\"solvent-a\"</code> or <code>\"solvent-b\"</code>.</p> </li> <li> <code>custom_alchemical_potential</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A custom expression to use for the potential energy function that describes the chemical-alchemical intermolecular interactions.</p> <p>See the <code>absolv.fep.apply_fep</code> function for more details.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[PreparedSystem, PreparedSystem]</code>           \u2013            <p>The two prepared systems, corresponding to solvent-a and solvent-b respectively.</p> </li> </ul> Source code in <code>absolv/runner.py</code> <pre><code>def setup(\n    system: absolv.config.System,\n    config: absolv.config.Config,\n    force_field: openff.toolkit.ForceField | absolv.utils.openmm.SystemGenerator,\n    custom_alchemical_potential: str | None = None,\n) -&gt; tuple[PreparedSystem, PreparedSystem]:\n    \"\"\"Prepare each system to be simulated, namely the ligand in each solvent.\n\n    Args:\n        system: The system to prepare.\n        config: The config defining the calculation to perform.\n        force_field: The force field, or a callable that transforms an OpenFF\n            topology into an OpenMM system, **without** any alchemical modifications\n            to run the calculations using.\n\n            If a callable is specified, it should take arguments of an OpenFF\n            topology, a unit wrapped numpy array of atom coords, and a string\n            literal with a value of either ``\"solvent-a\"`` or ``\"solvent-b\"``.\n        custom_alchemical_potential: A custom expression to use for the potential\n            energy function that describes the chemical-alchemical intermolecular\n            interactions.\n\n            See the ``absolv.fep.apply_fep`` function for more details.\n\n    Returns:\n        The two prepared systems, corresponding to solvent-a and solvent-b respectively.\n    \"\"\"\n\n    solvated_a = _setup_solvent(\n        \"solvent-a\",\n        system.components_a,\n        force_field,\n        system.n_solute_molecules,\n        system.n_solvent_molecules_a,\n        custom_alchemical_potential,\n    )\n    solvated_b = _setup_solvent(\n        \"solvent-b\",\n        system.components_b,\n        force_field,\n        system.n_solute_molecules,\n        system.n_solvent_molecules_b,\n        custom_alchemical_potential,\n    )\n\n    if system.solvent_a is not None and config.pressure is not None:\n        absolv.utils.openmm.add_barostat(\n            solvated_a.system, config.temperature, config.pressure\n        )\n    if system.solvent_b is not None and config.pressure is not None:\n        absolv.utils.openmm.add_barostat(\n            solvated_b.system, config.temperature, config.pressure\n        )\n\n    return solvated_a, solvated_b\n</code></pre>"},{"location":"reference/runner/#absolv.runner.run_eq","title":"run_eq","text":"<pre><code>run_eq(\n    config: Config,\n    prepared_system_a: PreparedSystem,\n    prepared_system_b: PreparedSystem,\n    platform: OpenMMPlatform = CUDA,\n    output_dir: Path | None = None,\n    parallel: bool = False,\n) -&gt; Result\n</code></pre> <p>Perform a simulation at each lambda window and for each solvent.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>Config</code>)           \u2013            <p>The config defining the calculation to perform.</p> </li> <li> <code>prepared_system_a</code>               (<code>PreparedSystem</code>)           \u2013            <p>The prepared system a. See <code>setup</code> for more details.</p> </li> <li> <code>prepared_system_b</code>               (<code>PreparedSystem</code>)           \u2013            <p>The prepared system b. See <code>setup</code> for more details.</p> </li> <li> <code>platform</code>               (<code>OpenMMPlatform</code>, default:                   <code>CUDA</code> )           \u2013            <p>The OpenMM platform to run using.</p> </li> <li> <code>output_dir</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) directory to save HREMD samples to.</p> </li> <li> <code>parallel</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to run calculations for solvent A and solvent B in parallel. This is mostly useful when running HFE calculations where the vacuum phase will typically run on the CPU while the solvent phase will run on the GPU.</p> </li> </ul> Source code in <code>absolv/runner.py</code> <pre><code>def run_eq(\n    config: absolv.config.Config,\n    prepared_system_a: PreparedSystem,\n    prepared_system_b: PreparedSystem,\n    platform: femto.md.constants.OpenMMPlatform = femto.md.constants.OpenMMPlatform.CUDA,\n    output_dir: pathlib.Path | None = None,\n    parallel: bool = False,\n) -&gt; absolv.config.Result:\n    \"\"\"Perform a simulation at each lambda window and for each solvent.\n\n    Args:\n        config: The config defining the calculation to perform.\n        prepared_system_a: The prepared system a. See ``setup`` for more details.\n        prepared_system_b: The prepared system b. See ``setup`` for more details.\n        platform: The OpenMM platform to run using.\n        output_dir: The (optional) directory to save HREMD samples to.\n        parallel: Whether to run calculations for solvent A and solvent B in\n            parallel. This is mostly useful when running HFE calculations where\n            the vacuum phase will typically run on the CPU while the solvent phase\n            will run on the GPU.\n    \"\"\"\n\n    output_dir_a = None if output_dir is None else output_dir / \"solvent-a\"\n    output_dir_b = None if output_dir is None else output_dir / \"solvent-b\"\n\n    args = [\n        (config.alchemical_protocol_a, prepared_system_a, output_dir_a),\n        (config.alchemical_protocol_b, prepared_system_b, output_dir_b),\n    ]\n    run_fn = functools.partial(\n        _run_eq_phase, temperature=config.temperature, platform=platform\n    )\n\n    if parallel:\n        with multiprocessing.Pool(2) as pool:\n            results = list(pool.starmap(run_fn, args))\n    else:\n        results = [run_fn(*args[0]), run_fn(*args[1])]\n\n    results_a, overlap_a = results[0]\n    results_b, overlap_b = results[1]\n\n    dg_a, dg_a_std = results_a[\"ddG_kcal_mol\"], results_a[\"ddG_error_kcal_mol\"]\n    # overlap_a = overlap_a[\"overlap_0\"]\n    dg_b, dg_b_std = results_b[\"ddG_kcal_mol\"], results_b[\"ddG_error_kcal_mol\"]\n    # overlap_b = overlap_b[\"overlap_0\"]\n\n    return absolv.config.Result(\n        dg_solvent_a=dg_a * openmm.unit.kilocalorie_per_mole,\n        dg_std_solvent_a=dg_a_std * openmm.unit.kilocalorie_per_mole,\n        dg_solvent_b=dg_b * openmm.unit.kilocalorie_per_mole,\n        dg_std_solvent_b=dg_b_std * openmm.unit.kilocalorie_per_mole,\n    )\n</code></pre>"},{"location":"reference/runner/#absolv.runner.run_neq","title":"run_neq","text":"<pre><code>run_neq(\n    config: Config,\n    prepared_system_a: PreparedSystem,\n    prepared_system_b: PreparedSystem,\n    platform: OpenMMPlatform = CUDA,\n) -&gt; Result\n</code></pre> <p>Performs the simulations required to estimate the free energy using a non-equilibrium method.</p> <p>These include equilibrium simulations at the two end states (i.e. fully interacting and fully de-coupled solute) for each solvent followed by non-equilibrium switching simulations between each end state to compute the forward and reverse work values.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>Config</code>)           \u2013            <p>The config defining the calculation to perform.</p> </li> <li> <code>prepared_system_a</code>               (<code>PreparedSystem</code>)           \u2013            <p>The prepared system a. See <code>setup</code> for more details.</p> </li> <li> <code>prepared_system_b</code>               (<code>PreparedSystem</code>)           \u2013            <p>The prepared system b. See <code>setup</code> for more details.</p> </li> <li> <code>platform</code>               (<code>OpenMMPlatform</code>, default:                   <code>CUDA</code> )           \u2013            <p>The OpenMM platform to run using.</p> </li> </ul> Source code in <code>absolv/runner.py</code> <pre><code>def run_neq(\n    config: absolv.config.Config,\n    prepared_system_a: PreparedSystem,\n    prepared_system_b: PreparedSystem,\n    platform: femto.md.constants.OpenMMPlatform = femto.md.constants.OpenMMPlatform.CUDA,\n) -&gt; absolv.config.Result:\n    \"\"\"Performs the simulations required to estimate the free energy using a\n    non-equilibrium method.\n\n    These include **equilibrium** simulations at the two end states (i.e. fully\n    interacting and fully de-coupled solute) for each solvent followed by\n    non-equilibrium switching simulations between each end state to compute the\n    forward and reverse work values.\n\n    Args:\n        config: The config defining the calculation to perform.\n        prepared_system_a: The prepared system a. See ``setup`` for more details.\n        prepared_system_b: The prepared system b. See ``setup`` for more details.\n        platform: The OpenMM platform to run using.\n    \"\"\"\n\n    with tempfile.TemporaryDirectory() as tmp_dir:\n        tmp_dir = pathlib.Path(tmp_dir)\n\n        solvent_a_dir = tmp_dir / \"solvent-a\"\n        solvent_b_dir = tmp_dir / \"solvent-b\"\n\n        _run_phase_end_states(\n            config.alchemical_protocol_a,\n            config.temperature,\n            prepared_system_a,\n            solvent_a_dir,\n            platform,\n        )\n        dg_a, dg_std_a = _run_switching(\n            config.alchemical_protocol_a,\n            config.temperature,\n            prepared_system_a,\n            solvent_a_dir,\n            platform,\n        )\n\n        _run_phase_end_states(\n            config.alchemical_protocol_b,\n            config.temperature,\n            prepared_system_b,\n            solvent_b_dir,\n            platform,\n        )\n        dg_b, dg_std_b = _run_switching(\n            config.alchemical_protocol_b,\n            config.temperature,\n            prepared_system_b,\n            solvent_b_dir,\n            platform,\n        )\n\n    return absolv.config.Result(\n        dg_solvent_a=dg_a.in_units_of(openmm.unit.kilocalories_per_mole),\n        dg_std_solvent_a=dg_std_a.in_units_of(openmm.unit.kilocalories_per_mole),\n        dg_solvent_b=dg_b.in_units_of(openmm.unit.kilocalories_per_mole),\n        dg_std_solvent_b=dg_std_b.in_units_of(openmm.unit.kilocalories_per_mole),\n    )\n</code></pre>"},{"location":"reference/setup/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> setup","text":""},{"location":"reference/setup/#absolv.setup","title":"setup","text":"<p>Setup systems ready for calculations.</p> <p>Functions:</p> <ul> <li> <code>setup_system</code>             \u2013              <p>Generate a set of molecule coordinate by using the PACKMOL package.</p> </li> </ul>"},{"location":"reference/setup/#absolv.setup.setup_system","title":"setup_system","text":"<pre><code>setup_system(\n    components: list[tuple[str, int]],\n    box_target_density: Quantity = 0.95 * _G_PER_ML,\n    box_scale_factor: float = 1.1,\n    box_padding: Quantity = 2.0 * angstrom,\n    tolerance: Quantity = 2.0 * angstrom,\n) -&gt; tuple[Topology, Quantity]\n</code></pre> <p>Generate a set of molecule coordinate by using the PACKMOL package.</p> <p>Parameters:</p> <ul> <li> <code>components</code>               (<code>list[tuple[str, int]]</code>)           \u2013            <p>A list of the form <code>components[i] = (smiles_i, count_i)</code> where <code>smiles_i</code> is the SMILES representation of component <code>i</code> and <code>count_i</code> is the number of corresponding instances of that component to create.</p> <p>If any SMILES is fully indexed an attempt will be made to create components with the same atom ordering as the indices.</p> </li> <li> <code>box_target_density</code>               (<code>Quantity</code>, default:                   <code>0.95 * _G_PER_ML</code> )           \u2013            <p>Target mass density when approximating the box size for the final system with units compatible with g / mL.</p> </li> <li> <code>box_scale_factor</code>               (<code>float</code>, default:                   <code>1.1</code> )           \u2013            <p>The amount to scale the approximate box size by.</p> </li> <li> <code>box_padding</code>               (<code>Quantity</code>, default:                   <code>2.0 * angstrom</code> )           \u2013            <p>The amount of extra padding to add to the box size to avoid PBC issues in units compatible with angstroms.</p> </li> <li> <code>tolerance</code>               (<code>Quantity</code>, default:                   <code>2.0 * angstrom</code> )           \u2013            <p>The minimum spacing between molecules during packing in units  compatible with angstroms.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Topology, Quantity]</code>           \u2013            <p>A topology containing the molecules the coordinates were generated for and a unit [A] wrapped numpy array of coordinates with shape=(n_atoms, 3).</p> </li> </ul> Source code in <code>absolv/setup.py</code> <pre><code>def setup_system(\n    components: list[tuple[str, int]],\n    box_target_density: openmm.unit.Quantity = 0.95 * _G_PER_ML,\n    box_scale_factor: float = 1.1,\n    box_padding: openmm.unit.Quantity = 2.0 * openmm.unit.angstrom,\n    tolerance: openmm.unit.Quantity = 2.0 * openmm.unit.angstrom,\n) -&gt; tuple[openff.toolkit.Topology, openmm.unit.Quantity]:\n    \"\"\"Generate a set of molecule coordinate by using the PACKMOL package.\n\n    Args:\n        components: A list of the form ``components[i] = (smiles_i, count_i)`` where\n            ``smiles_i`` is the SMILES representation of component `i` and\n            ``count_i`` is the number of corresponding instances of that component\n            to create.\n\n            If any SMILES is fully indexed an attempt will be made to create components\n            with the same atom ordering as the indices.\n        box_target_density: Target mass density when approximating the box size for the\n            final system with units compatible with g / mL.\n        box_scale_factor: The amount to scale the approximate box size by.\n        box_padding: The amount of extra padding to add to the box size to avoid PBC\n            issues in units compatible with angstroms.\n        tolerance: The minimum spacing between molecules during packing in units\n             compatible with angstroms.\n\n    Returns:\n        A topology containing the molecules the coordinates were generated for and\n        a unit [A] wrapped numpy array of coordinates with shape=(n_atoms, 3).\n    \"\"\"\n\n    packmol_path = shutil.which(\"packmol\")\n\n    if packmol_path is None:\n        raise FileNotFoundError(errno.ENOENT, os.strerror(errno.ENOENT), \"packmol\")\n\n    box_size = (\n        _approximate_box_size_by_density(components, box_target_density)\n        * box_scale_factor\n    )\n\n    molecules = {}\n\n    for smiles, _ in components:\n        if smiles in molecules:\n            continue\n\n        molecule = _molecule_from_smiles(smiles)\n        molecule.generate_conformers(n_conformers=1)\n        molecule.name = f\"component-{len(molecules)}.xyz\"\n        molecules[smiles] = molecule\n\n    with openff.utilities.temporary_cd():\n        for molecule in molecules.values():\n            molecule.to_file(molecule.name, \"xyz\")\n\n        input_file_contents = _generate_input_file(\n            [(molecules[smiles].name, count) for smiles, count in components],\n            box_size,\n            tolerance,\n        )\n\n        with open(\"input.txt\", \"w\") as file:\n            file.write(input_file_contents)\n\n        with open(\"input.txt\") as file:\n            subprocess.run(packmol_path, stdin=file, check=True, capture_output=True)\n\n        with open(\"output.xyz\") as file:\n            output_lines = file.read().splitlines(False)\n\n    coordinates = (\n        numpy.array(\n            [\n                [float(coordinate) for coordinate in coordinate_line.split()[1:]]\n                for coordinate_line in output_lines[2:]\n                if len(coordinate_line) &gt; 0\n            ]\n        )\n        * openmm.unit.angstrom\n    )\n\n    topology = openff.toolkit.Topology.from_molecules(\n        [molecules[smiles] for smiles, count in components for _ in range(count)]\n    )\n    topology.box_vectors = numpy.eye(3) * (box_size + box_padding)\n\n    return topology, coordinates\n</code></pre>"},{"location":"reference/utils/","title":"Index","text":""},{"location":"reference/utils/#absolv.utils","title":"utils","text":"<p>Common utils</p> <p>Modules:</p> <ul> <li> <code>openmm</code>           \u2013            <p>Utilities to manipulate OpenMM objects.</p> </li> <li> <code>topology</code>           \u2013            <p>Utilities for manipulating OpenFF topology objects.</p> </li> </ul>"},{"location":"reference/utils/openmm/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> openmm","text":""},{"location":"reference/utils/openmm/#absolv.utils.openmm","title":"openmm","text":"<p>Utilities to manipulate OpenMM objects.</p> <p>Functions:</p> <ul> <li> <code>add_barostat</code>             \u2013              <p>Add a barostat to a system in-place.</p> </li> <li> <code>create_simulation</code>             \u2013              <p>Creates an OpenMM simulation object.</p> </li> <li> <code>create_system_generator</code>             \u2013              <p>Creates a 'system generator' that can be used when setting up an alchemical</p> </li> <li> <code>extract_frame</code>             \u2013              <p>Extracts a frame from a trajectory as an OpenMM state object.</p> </li> </ul>"},{"location":"reference/utils/openmm/#absolv.utils.openmm.add_barostat","title":"add_barostat","text":"<pre><code>add_barostat(\n    system: System,\n    temperature: Quantity,\n    pressure: Quantity,\n    frequency: int = 25,\n)\n</code></pre> <p>Add a barostat to a system in-place.</p> <p>Parameters:</p> <ul> <li> <code>system</code>               (<code>System</code>)           \u2013            <p>The system to add the barostat to.</p> </li> <li> <code>temperature</code>               (<code>Quantity</code>)           \u2013            <p>The temperature to simulate at.</p> </li> <li> <code>pressure</code>               (<code>Quantity</code>)           \u2013            <p>The pressure to simulate at.</p> </li> <li> <code>frequency</code>               (<code>int</code>, default:                   <code>25</code> )           \u2013            <p>The frequency at which to apply the barostat.</p> </li> </ul> Source code in <code>absolv/utils/openmm.py</code> <pre><code>def add_barostat(\n    system: openmm.System,\n    temperature: openmm.unit.Quantity,\n    pressure: openmm.unit.Quantity,\n    frequency: int = 25,\n):\n    \"\"\"Add a barostat to a system in-place.\n\n    Args:\n        system: The system to add the barostat to.\n        temperature: The temperature to simulate at.\n        pressure: The pressure to simulate at.\n        frequency: The frequency at which to apply the barostat.\n    \"\"\"\n\n    barostats = [\n        force\n        for force in system.getForces()\n        if isinstance(force, openmm.MonteCarloBarostat)\n    ]\n    assert len(barostats) == 0, \"the system should not already contain a barostat\"\n\n    system.addForce(openmm.MonteCarloBarostat(pressure, temperature, frequency))\n</code></pre>"},{"location":"reference/utils/openmm/#absolv.utils.openmm.create_simulation","title":"create_simulation","text":"<pre><code>create_simulation(\n    system: System,\n    topology: Topology,\n    coords: Quantity,\n    integrator: Integrator,\n    platform: OpenMMPlatform,\n) -&gt; Simulation\n</code></pre> <p>Creates an OpenMM simulation object.</p> <p>Parameters:</p> <ul> <li> <code>system</code>               (<code>System</code>)           \u2013            <p>The system to simulate</p> </li> <li> <code>topology</code>               (<code>Topology</code>)           \u2013            <p>The topology being simulated.</p> </li> <li> <code>coords</code>               (<code>Quantity</code>)           \u2013            <p>The initial coordinates. Box vectors (if any) will be taken from the topology.</p> </li> <li> <code>integrator</code>               (<code>Integrator</code>)           \u2013            <p>The integrator to evolve the system with.</p> </li> <li> <code>platform</code>               (<code>OpenMMPlatform</code>)           \u2013            <p>The accelerator to run using.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Simulation</code>           \u2013            <p>The created simulation.</p> </li> </ul> Source code in <code>absolv/utils/openmm.py</code> <pre><code>def create_simulation(\n    system: openmm.System,\n    topology: openff.toolkit.Topology,\n    coords: openmm.unit.Quantity,\n    integrator: openmm.Integrator,\n    platform: femto.md.constants.OpenMMPlatform,\n) -&gt; openmm.app.Simulation:\n    \"\"\"Creates an OpenMM simulation object.\n\n    Args:\n        system: The system to simulate\n        topology: The topology being simulated.\n        coords: The initial coordinates. Box vectors (if any) will be taken from the\n            topology.\n        integrator: The integrator to evolve the system with.\n        platform: The accelerator to run using.\n\n    Returns:\n        The created simulation.\n    \"\"\"\n    platform_properties = (\n        {\"Precision\": \"mixed\"} if platform.upper() in [\"CUDA\", \"OPENCL\"] else {}\n    )\n    platform = openmm.Platform.getPlatformByName(platform)\n\n    if topology.box_vectors is not None:\n        system.setDefaultPeriodicBoxVectors(*topology.box_vectors.to_openmm())\n\n    simulation = openmm.app.Simulation(\n        topology.to_openmm(), system, integrator, platform, platform_properties\n    )\n\n    if topology.box_vectors is not None:\n        simulation.context.setPeriodicBoxVectors(*topology.box_vectors.to_openmm())\n\n    simulation.context.setPositions(coords)\n    simulation.context.setVelocitiesToTemperature(integrator.getTemperature())\n\n    return simulation\n</code></pre>"},{"location":"reference/utils/openmm/#absolv.utils.openmm.create_system_generator","title":"create_system_generator","text":"<pre><code>create_system_generator(\n    force_field: ForceField,\n    solvent_a_nonbonded_method: int,\n    solvent_b_nonbonded_method: int,\n    nonbonded_cutoff: Quantity = 1.0 * nanometer,\n    constraints: int | None = None,\n    rigid_water: bool | None = None,\n    remove_cmm_motion: bool = True,\n    hydrogen_mass: Quantity | None = None,\n    switch_distance: Quantity | None = None,\n) -&gt; SystemGenerator\n</code></pre> <p>Creates a 'system generator' that can be used when setting up an alchemical free energy calculation from an OpenMM force field.</p> <p>Parameters:</p> <ul> <li> <code>force_field</code>               (<code>ForceField</code>)           \u2013            <p>The OpenMM force field to parameterize the topology using.</p> </li> <li> <code>solvent_a_nonbonded_method</code>               (<code>int</code>)           \u2013            <p>The non-bonded method to use in solvent a.</p> </li> <li> <code>solvent_b_nonbonded_method</code>               (<code>int</code>)           \u2013            <p>The non-bonded method to use in solvent b.</p> </li> <li> <code>nonbonded_cutoff</code>               (<code>Quantity</code>, default:                   <code>1.0 * nanometer</code> )           \u2013            <p>The non-bonded cutoff to use.</p> </li> <li> <code>constraints</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The type of constraints to apply to the system.</p> </li> <li> <code>rigid_water</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to force rigid water.</p> </li> <li> <code>remove_cmm_motion</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to remove any CMM motion.</p> </li> <li> <code>hydrogen_mass</code>               (<code>Quantity | None</code>, default:                   <code>None</code> )           \u2013            <p>The mass to use for hydrogens.</p> </li> <li> <code>switch_distance</code>               (<code>Quantity | None</code>, default:                   <code>None</code> )           \u2013            <p>The switch distance to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SystemGenerator</code>           \u2013            <p>A callable that will create an OpenMM system from an OpenFF topology and the name of the solvent (i.e. <code>\"solvent-a\"</code> or <code>\"solvent-b\"</code>) the system will be used for.</p> </li> </ul> Source code in <code>absolv/utils/openmm.py</code> <pre><code>def create_system_generator(\n    force_field: openmm.app.ForceField,\n    solvent_a_nonbonded_method: int,\n    solvent_b_nonbonded_method: int,\n    nonbonded_cutoff: openmm.unit.Quantity = 1.0 * openmm.unit.nanometer,\n    constraints: int | None = None,\n    rigid_water: bool | None = None,\n    remove_cmm_motion: bool = True,\n    hydrogen_mass: openmm.unit.Quantity | None = None,\n    switch_distance: openmm.unit.Quantity | None = None,\n) -&gt; SystemGenerator:\n    \"\"\"Creates a 'system generator' that can be used when setting up an alchemical\n    free energy calculation from an OpenMM force field.\n\n    Args:\n        force_field: The OpenMM force field to parameterize the topology using.\n        solvent_a_nonbonded_method: The non-bonded method to use in solvent a.\n        solvent_b_nonbonded_method: The non-bonded method to use in solvent b.\n        nonbonded_cutoff: The non-bonded cutoff to use.\n        constraints: The type of constraints to apply to the system.\n        rigid_water: Whether to force rigid water.\n        remove_cmm_motion: Whether to remove any CMM motion.\n        hydrogen_mass: The mass to use for hydrogens.\n        switch_distance: The switch distance to use.\n\n    Returns:\n        A callable that will create an OpenMM system from an OpenFF topology and the\n        name of the solvent (i.e. ``\"solvent-a\"`` or ``\"solvent-b\"``) the system will\n        be used for.\n    \"\"\"\n\n    def system_generator(\n        topology: openff.toolkit.Topology,\n        coordinates: openmm.unit.Quantity,\n        solvent_idx: typing.Literal[\"solvent-a\", \"solvent-b\"],\n    ) -&gt; openmm.System:\n        openmm_topology = topology.to_openmm()\n\n        if topology.box_vectors is not None:\n            openmm_topology.setPeriodicBoxVectors(topology.box_vectors.to_openmm())\n\n        # We need to fix the special case of water in order for OMM to correctly apply\n        # a constraint between H atoms.\n        for chain in openmm_topology.chains():\n            for residue in chain.residues():\n                if len(residue) != 3:\n                    continue\n\n                symbols = sorted(atom.element.symbol for atom in residue.atoms())\n\n                if symbols == [\"H\", \"H\", \"O\"]:\n                    residue.name = \"HOH\"\n\n        from openmm.app import Modeller\n\n        modeller = Modeller(\n            openmm_topology,\n            [\n                openmm.Vec3(coordinate[0], coordinate[1], coordinate[2])\n                for coordinate in coordinates.value_in_unit(openmm.unit.nanometers)\n            ]\n            * openmm.unit.nanometers,\n        )\n        modeller.addExtraParticles(force_field)\n\n        system = force_field.createSystem(\n            modeller.getTopology(),\n            nonbondedMethod=(\n                solvent_a_nonbonded_method\n                if solvent_idx == \"solvent-a\"\n                else solvent_b_nonbonded_method\n            ),\n            nonbondedCutoff=nonbonded_cutoff,\n            constraints=constraints,\n            rigidWater=rigid_water,\n            removeCMMotion=remove_cmm_motion,\n            hydrogenMass=hydrogen_mass,\n            switchDistance=switch_distance,\n        )\n\n        return system\n\n    return system_generator\n</code></pre>"},{"location":"reference/utils/openmm/#absolv.utils.openmm.extract_frame","title":"extract_frame","text":"<pre><code>extract_frame(trajectory: Trajectory, idx: int) -&gt; State\n</code></pre> <p>Extracts a frame from a trajectory as an OpenMM state object.</p> <p>Parameters:</p> <ul> <li> <code>trajectory</code>               (<code>Trajectory</code>)           \u2013            <p>The trajectory to extract the frame from.</p> </li> <li> <code>idx</code>               (<code>int</code>)           \u2013            <p>The index of the frame to extract.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>State</code>           \u2013            <p>The extracted frame.</p> </li> </ul> Source code in <code>absolv/utils/openmm.py</code> <pre><code>def extract_frame(trajectory: mdtraj.Trajectory, idx: int) -&gt; openmm.State:\n    \"\"\"Extracts a frame from a trajectory as an OpenMM state object.\n\n    Args:\n        trajectory: The trajectory to extract the frame from.\n        idx: The index of the frame to extract.\n\n    Returns:\n        The extracted frame.\n    \"\"\"\n\n    system = openmm.System()\n\n    for _ in range(trajectory.n_atoms):\n        system.addParticle(1.0 * openmm.unit.dalton)\n\n    context = openmm.Context(system, openmm.VerletIntegrator(0.0001))\n    context.setPositions(trajectory.openmm_positions(idx))\n\n    if trajectory.unitcell_vectors is not None:\n        context.setPeriodicBoxVectors(*trajectory.openmm_boxes(idx))\n\n    return context.getState(getPositions=True)\n</code></pre>"},{"location":"reference/utils/topology/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> topology","text":""},{"location":"reference/utils/topology/#absolv.utils.topology","title":"topology","text":"<p>Utilities for manipulating OpenFF topology objects.</p> <p>Functions:</p> <ul> <li> <code>topology_to_components</code>             \u2013              <p>A helper method for condensing a topology down to a list of components</p> </li> <li> <code>topology_to_atom_indices</code>             \u2013              <p>A helper method for extracting the sets of atom indices associated with each</p> </li> </ul>"},{"location":"reference/utils/topology/#absolv.utils.topology.topology_to_components","title":"topology_to_components","text":"<pre><code>topology_to_components(\n    topology: Topology,\n) -&gt; list[tuple[str, int]]\n</code></pre> <p>A helper method for condensing a topology down to a list of components and their counts.</p> Notes <p>If the topology is not contiguous then the returned list may contain multiple tuples with the same smiles but different counts.</p> <p>Parameters:</p> <ul> <li> <code>topology</code>               (<code>Topology</code>)           \u2013            <p>The topology to condense.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[tuple[str, int]]</code>           \u2013            <p>A list of the form <code>components[i] = (smiles_i, count_i)</code> where <code>smiles_i</code> is the SMILES representation of component <code>i</code> and <code>count_i</code> is the number of corresponding instances of that component to create.</p> </li> </ul> Source code in <code>absolv/utils/topology.py</code> <pre><code>def topology_to_components(topology: openff.toolkit.Topology) -&gt; list[tuple[str, int]]:\n    \"\"\"A helper method for condensing a topology down to a list of components\n    and their counts.\n\n    Notes:\n        If the topology is not contiguous then the returned list may contain multiple\n        tuples with the same smiles but different counts.\n\n    Args:\n        topology: The topology to condense.\n\n    Returns:\n        A list of the form ``components[i] = (smiles_i, count_i)`` where\n        ``smiles_i`` is the SMILES representation of component `i` and\n        ``count_i`` is the number of corresponding instances of that component\n        to create.\n    \"\"\"\n    components = []\n\n    current_smiles = None\n    current_count = 0\n\n    for molecule in topology.molecules:\n        smiles = molecule.to_smiles()\n\n        if smiles == current_smiles:\n            current_count += 1\n            continue\n\n        if current_count &gt; 0:\n            components.append((current_smiles, current_count))\n\n        current_smiles = smiles\n        current_count = 1\n\n    if current_count &gt; 0:\n        components.append((current_smiles, current_count))\n\n    return components\n</code></pre>"},{"location":"reference/utils/topology/#absolv.utils.topology.topology_to_atom_indices","title":"topology_to_atom_indices","text":"<pre><code>topology_to_atom_indices(\n    topology: Topology,\n) -&gt; list[set[int]]\n</code></pre> <p>A helper method for extracting the sets of atom indices associated with each molecule in a topology.</p> <p>Parameters:</p> <ul> <li> <code>topology</code>               (<code>Topology</code>)           \u2013            <p>The topology to extract the atom indices from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[set[int]]</code>           \u2013            <p>The set of atoms indices associated with each molecule in the topology.</p> </li> </ul> Source code in <code>absolv/utils/topology.py</code> <pre><code>def topology_to_atom_indices(topology: openff.toolkit.Topology) -&gt; list[set[int]]:\n    \"\"\"A helper method for extracting the sets of atom indices associated with each\n    molecule in a topology.\n\n    Args:\n        topology: The topology to extract the atom indices from.\n\n    Returns:\n        The set of atoms indices associated with each molecule in the topology.\n    \"\"\"\n\n    atom_indices: list[set[int]] = []\n    current_atom_idx = 0\n\n    for molecule in topology.molecules:\n        atom_indices.append({i + current_atom_idx for i in range(molecule.n_atoms)})\n        current_atom_idx += molecule.n_atoms\n\n    return atom_indices\n</code></pre>"},{"location":"user-guide/overview/","title":"Overview","text":"<p>To begin with, we define a configuration that encodes the entirety of the absolute free energy calculation.</p> <p>This includes specifying the solutes and the two solvents that they will be transferred between:</p> <pre><code>import absolv.config\n\nsystem=absolv.config.System(\n    solutes={\"CCO\": 1}, solvent_a=None, solvent_b={\"O\": 895}\n)\n</code></pre> <p>Each key should be a SMILES representation of a molecule, and the value should be the number of copies of that molecule to include in the system. There may be multiple in the case of, e.g., ion pairs like <code>Na+</code> and <code>Cl-</code>. <code>None</code> may be used to specify vacuum, e.g., in the above case that the solute will be transferred from vacuum into bulk water.</p> <p>The temperature and pressure that the calculation will be performed at must also be specified:</p> <pre><code>import openmm.unit\n\ntemperature=298.15 * openmm.unit.kelvin,\npressure=1.0 * openmm.unit.atmosphere\n</code></pre> <p>Finally, the alchemical pathway to transform the solute along in each solvent must be specified. This can either be a more traditional 'equilibrium' pathway, or a 'non-equilibrium' pathway:</p> EquilibriumNon-equilibrium <pre><code>import absolv.config\n\nalchemical_protocol_a=absolv.config.EquilibriumProtocol(\n    lambda_sterics=[1.0, 1.0, 1.0, 1.0, 1.0],\n    lambda_electrostatics=[1.0, 0.75, 0.5, 0.25, 0.0]\n)\nalchemical_protocol_b=absolv.config.EquilibriumProtocol(\n    lambda_sterics=[\n        1.00, 1.00, 1.00, 1.00, 1.00, 0.95, 0.90, 0.80, 0.70, 0.60, 0.50, 0.40,\n        0.35, 0.30, 0.25, 0.20, 0.15, 0.10, 0.05, 0.00,\n    ],\n    lambda_electrostatics=[\n        1.00, 0.75, 0.50, 0.25, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,\n        0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,\n    ]\n)\n</code></pre> <p>Here the default lambda schedule from FreeSolv is used. A lambda of <code>1.0</code> indicates a fully interacting system, and a lambda of <code>0.0</code> indicates a fully decoupled system.</p> <pre><code>import femto.md.config\nimport openmm.unit\n\nimport absolv.config\n\nintegrator = femto.md.config.LangevinIntegrator(\n    timestep=2.0 * openmm.unit.femtoseconds\n)\n\nalchemical_protocol_a=absolv.config.NonEquilibriumProtocol(\n    # the protocol to use for the production run at each end state\n    production_protocol=absolv.config.SimulationProtocol(\n        integrator=integrator, n_steps=6250 * 160\n    ),\n    # the interval with which to store frames that NEQ switching\n    # simulations will be launched from\n    production_report_interval=6250,\n    # define how the NEQ switching will be performed\n    switching_protocol=absolv.config.SwitchingProtocol(\n        n_electrostatic_steps=60,\n        n_steps_per_electrostatic_step=100,\n        # intra-molecular vdW interactions are not decoupled by default, so we\n        # don't need to do any vdW decoupling in vacuum when there's only one solvent\n        n_steric_steps=0,\n        n_steps_per_steric_step=0\n    )\n)\nalchemical_protocol_b=absolv.config.NonEquilibriumProtocol(\n    production_protocol=absolv.config.SimulationProtocol(\n        integrator=integrator, n_steps=6250 * 160,\n    ),\n    switching_protocol=absolv.config.SwitchingProtocol(\n        # Annihilate the electrostatic interactions over the first 12 ps\n        n_electrostatic_steps=60,\n        n_steps_per_electrostatic_step=100,\n        # followed by decoupling the vdW interactions over the next 38 ps\n        n_steric_steps=190,\n        n_steps_per_steric_step=100,\n    )\n)\n</code></pre> <p>These individual components are then combined into a single configuration object:</p> <pre><code>import absolv.config\n\nconfig = absolv.config.Config(\n    temperature=temperature,\n    pressure=pressure,\n    alchemical_protocol_a=alchemical_protocol_a,\n    alchemical_protocol_b=alchemical_protocol_b,\n)\n</code></pre> <p>which can be used to trivially set up</p> <pre><code>import openff.toolkit\nforce_field = openff.toolkit.ForceField(\"openff-2.1.0.offxml\")\n\nimport absolv.runner\nprepared_system_a, prepared_system_b = absolv.runner.setup(system, config, force_field)\n</code></pre> <p>and run the calculation:</p> EquilibriumNon-equilibrium <pre><code>result = absolv.runner.run_eq(\n    config, prepared_system_a, prepared_system_b, \"CUDA\"\n)\nprint(result)\n</code></pre> <pre><code>result = absolv.runner.run_neq(\n    config, prepared_system_a, prepared_system_b, \"CUDA\"\n)\nprint(result)\n</code></pre> <p>where the result will be a Result object.</p>"},{"location":"user-guide/theory/","title":"Theory","text":"<p>The change in free energy of transferring a solute from one solvent to another \\(\\Delta G_{A-&gt;B}\\), can be readily computed by constructing a thermodynamic cycle in which the solute in each solvent is alchemically transformed into a non-interacting state as shown below:</p> <p></p> <p>Namely,</p> \\[ \\Delta G_{A-&gt;B} = \\Delta G_1 - \\Delta G_3 \\] <p>where here \\(\\Delta G_1\\) and \\(\\Delta G_3\\) are the change in free energy of alchemically transforming a solute (or perhaps multiple solutes in the case of charged molecules with counter ions) so that it no longer interacts with the surrounding corresponding 'solvent'.</p> <p>Computing the solvation (/ hydration) free energy is a special case of this cycle when the first 'solvent' is vacuum.</p> <p>This framework currently offers two routes to computing such a change in free energy as the solute is being alchemically transformed, a more commonly used 'equilibrium route' and a 'non-equilibrium' route.</p> Note <p>For more information about how the different inter- and intramolecular interactions are alchemically modified see the transformations page.</p>"},{"location":"user-guide/theory/#equilibrium-calculations","title":"Equilibrium Calculations","text":"<p>Within this framework we refer to free energy calculations that involve dividing the alchemical pathway into discrete windows at each value of the coupling parameter \\(\\lambda\\), collecting equilibrium samples for each such discrete state, and using these samples to compute the free energy using an approach such as thermodynamic integration (TI) <sup>1</sup>, BAR <sup>2</sup>, and MBAR <sup>3</sup> as 'equilibrium' free energy calculations.</p> <p>At present <code>absolv</code> does not offer functionality for computing the derivatives with respect to lambda required for TI, and only supports MBAR and technically BAR although this estimator is not recommended.</p> <p>See the overview for more information on running equilibrium free energy calculations using <code>absolv</code>.</p>"},{"location":"user-guide/theory/#non-equilibrium-calculations","title":"Non-equilibrium Calculations","text":"<p>Within this framework we refer to free energy calculations that proceed by generating equilibrium configurations at both end states (with the solute fully interacting with the solute and with the solute-solvent interactions fully decoupled / annihilated), and then driving each configuration non-reverisbly along the alchemical pathway by scaling the coupling factor \\(\\lambda\\) as a function of time <sup>4</sup>.</p> <p>From a practical perspective it is computationally more efficient and convenient to proceed along the alchemical pathway in a stepwise, rather than continuous fashion. More specifically, the protocol proceeds by making a perturbation to \\(\\lambda\\), followed by several relaxation steps, and repeating these two sub-stebs until the alchemical transformation is complete.</p> <p></p> <p>in this way the required to transform the solute from the interacting to the non-interacting state and likewise from the non-interacting to the interacting state can be computed according to</p> \\[W = \\sum_{i=0}^{n-1} \\left[u_{\\lambda_{i+1}}\\left(x_i\\right) - u_{\\lambda_{i}}\\left(x_i\\right)\\right]\\] <p>where here \\(u_{\\lambda_i}\\left(x_i\\right)\\) is the reduced potential evaluated at configuration \\(i\\) and \\(\\lambda_i\\).</p> <p>The free energy is then estimated by solving</p> \\[\\sum^N_{i=1}\\dfrac{1}{1+\\exp(\\beta(W^f_i-\\Delta F))} = \\sum^N_{i=1}\\dfrac{1}{1+\\exp(\\beta(W^r_i+\\Delta F))}\\] <p>self consistently where \\(W^f_i\\) corresponds to work computed along the forward pathway going from the interacting to the non-interacting state and \\(W^r_i\\) to work computed along the reverse pathway going from the non-interacting to the interacting state. \\(N\\) refers to the total number of equilibrium snapshots that were generated at each end state.</p> <ol> <li> <p>TP Straatsma and JA McCammon. Computational alchemy. Annual Review of Physical Chemistry, 43(1):407\u2013435, 1992.\u00a0\u21a9</p> </li> <li> <p>Charles H Bennett. Efficient estimation of free energy differences from monte carlo data. Journal of Computational Physics, 22(2):245\u2013268, 1976.\u00a0\u21a9</p> </li> <li> <p>Michael R Shirts and John D Chodera. Statistically optimal analysis of samples from multiple equilibrium states. The Journal of chemical physics, 129(12):124105, 2008.\u00a0\u21a9</p> </li> <li> <p>Andrew J Ballard and Christopher Jarzynski. Replica exchange with nonequilibrium switches: enhancing equilibrium sampling by increasing replica overlap. The Journal of chemical physics, 136(19):194101, 2012.\u00a0\u21a9</p> </li> </ol>"},{"location":"user-guide/transformations/","title":"Transformations","text":"<p>The <code>absolv</code> framework supports alchemically transforming the electrostatic and vdW interactions within an OpenMM <code>System</code> object via the absolv.fep.apply_fep function.</p> <p>Due to the huge flexibility of the OpenMM system, allowing completely custom electrostatic and vdW forces to be implemented, it would be impossible to support all possible combinations of non-bonded forces. As such, the framework currently only systems that contain</p> <ul> <li>vdW + electrostatic interactions in a single built-in <code>NonbondedForce</code> object</li> <li>electrostatic interactions in a built-in <code>NonbondedForce</code> object, vdW interactions in a <code>CustomNonbondedForce</code>     object and vdW 1-4 interactions in a <code>CustomBondForce</code></li> <li>the above combinations sans any electrostatics interactions</li> </ul> <p>are supported.</p>"},{"location":"user-guide/transformations/#electrostatics","title":"Electrostatics","text":"<p>The electrostatic interactions in the system are alchemically transformed by linearly scaling all partial charges on particles in solute molecules by \\(\\lambda_{elec}\\), corresponding to a <code>\"lambda_electrostatics\"</code> context variable that will be added by the factory, such that</p> \\[q^{sol}_i \\left(\\lambda_{elec}\\right) = \\lambda_{elec} \\times q^{sol}_i\\] <p>All intramolecular interactions will be switched off during the alchemical transformation. This is referred to as 'annihilating' the electrostatic interactions in other packages and some literature.</p> <p>Because the charges are scaled directly, the energy contributions of the alchemically scaled electrostatic interactions will be</p> \\[U^E = \\lambda_{elec} U^E_{sol-solv} + \\lambda_{elec}^2 U^E_{sol-sol} + U^E_{solv-solv}\\] <p>where \\(U^E_{sol-sol}\\), \\(U^E_{sol-solv}\\) and \\(U^E_{solv-solv}\\) are the un-scaled electrostatic contributions to the energies of the solute-solute, solute-solvent and solvent-solvent interactions respectively.</p>"},{"location":"user-guide/transformations/#vdw","title":"vdW","text":"<p>Currently vdW interactions can only be transformed if they are stored in a standard <code>NonbondedForce</code> OR if they are split between a <code>CustomBondForce</code> (1-2, 1-3, and 1-4 interactions) and a <code>CustomNonbondedForce</code> (the remaining 1-n and intermolecular interactions).</p> <p>The interactions will be transformed according to \\(\\lambda_{vdW}\\) which corresponds to a <code>\"lambda_sterics\"</code> context variable that will be added by the factory.</p> <p>Only intermolecular vdW interactions will be alchemically scaled, while all intramolecular interactions will be left un-scaled. This is is referred to as 'decoupling' the vdW interactions in other packages and some literature.</p>"},{"location":"user-guide/transformations/#lennard-jones","title":"Lennard--Jones","text":"<p>If the vdW interactions are stored in a standard <code>NonbondedForce</code>, then the alchemical factory will split them so that</p> <ul> <li> <p>the <code>NonbondedForce</code> force retains all interactions between solvent particles</p> </li> <li> <p>all intermolecular alchemical (both solute-solvent and solute-solute) interactions are moved into a new     <code>CustomNonbondedForce</code></p> </li> <li> <p>all solute intramolecular interactions are moved into a new <code>CustomNonbondedForce</code></p> Note <p>The intramolecular solute-solute interactions won't use any periodic boundary corrections such that the the decoupled state of the solute corresponds to the proper vacuum state without periodicity effects.</p> </li> </ul> <p>The <code>CustomNonbondedForce</code> will copy over all settings (including cut-off, long-range correction, etc) from the original <code>NonbondedForce</code>, but will replace the normal LJ energy expression with a soft-core version. By default, this takes the form:</p> \\[U^{vdW} \\left( \\lambda_{vdW} \\right) = \\lambda_{vdW} \\times 4 \\varepsilon \\left[ \\left( \\dfrac{\\sigma}{r_{eff}}\\right)^{12} - \\left( \\dfrac{\\sigma}{r_{eff}}\\right)^{6} \\right]\\] <p>where</p> \\[r_{eff} = \\sigma \\left( \\dfrac{1}{2} \\left(1 - \\lambda_{vdW}\\right) + \\left( \\dfrac{r}{\\sigma} \\right) ^ 6 \\right) ^ \\frac{1}{6}\\]"},{"location":"user-guide/transformations/#custom-vdw-forms","title":"Custom vdW Forms","text":"<p>If the vdW interactions are split across a <code>CustomNonbondedForce</code> and a <code>CustomBondForce</code> then the alchemical factory will further split them so that</p> <ul> <li> <p>the original <code>CustomNonbondedForce</code> force will retain all interactions between solvent particles</p> </li> <li> <p>all solute intramolecular interactions are moved into a new <code>CustomNonbondedForce</code></p> Note <p>The intramolecular solute-solute interactions won't use any periodic boundary corrections such that the the decoupled state of the solute corresponds to the proper vacuum state without periodicity effects.</p> </li> <li> <p>all intermolecular alchemical (both solute-solvent and solute-solute) interactions are moved into another new     <code>CustomNonbondedForce</code> with a modified energy expression such that</p> \\[U^{vdW}_{sol-solv} \\left( \\lambda_{vdW} \\right) = \\lambda_{vdW} \\times U^{vdW}_{sol-solv}\\] </li> </ul>"}]}